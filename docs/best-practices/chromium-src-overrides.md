# chromium_src Overrides

## ❌ Don't Use chromium_src Overrides to Disable Tests

**Never use `#define TestName DISABLED_TestName` in chromium_src overrides to disable upstream tests.** Use filter files in `test/filters/` instead, and move any Brave-specific replacement tests into the appropriate Brave test target (`brave_unit_tests`, `brave_browser_tests`, `brave_components_unittests`). See [Disabled Test Investigations](../testing-requirements.md#disabled-test-investigations-fixing--re-enabling) for the full pattern and examples.

---

## ✅ Minimize Code Duplication in Overrides

**When overriding Chromium code via `chromium_src/`, prefer wrapping only the changed section and falling back to `ChromiumImpl` for everything else.**

Don't duplicate entire functions when only part of the logic needs to change.

**BAD:**
```cpp
// ❌ WRONG - duplicating the entire function
SkColor ChromeTypographyProvider::GetColor(...) {
  // 50 lines copied from upstream...
  // only 3 lines are actually different
}
```

**GOOD:**
```cpp
// ✅ CORRECT - wrap only the changed section
SkColor ChromeTypographyProvider::GetColor(...) {
  if (!ShouldIgnoreHarmonySpec(*native_theme)) {
    return ChromiumImpl::GetColor(...);  // Fallback to upstream
  }
  // Only our custom logic here
}
```

---

## ✅ Prefer chromium_src Overrides Over Patches

**Always prefer a chromium_src override over adding a patch.** Patches are harder to maintain, more likely to conflict, and harder to review. Required header files should be added through chromium_src overrides, not patches.

```cpp
// ❌ WRONG - adding a patch to include a header
// In patches/chromium/some_patch.patch
+#include "brave/components/my_feature/my_header.h"

// ✅ CORRECT - chromium_src override
// In chromium_src/chrome/browser/some_file.cc
#include "brave/components/my_feature/my_header.h"
```

When you need to add virtual to a method, add a class method, or intercept behavior, always use chromium_src overrides instead of patches.

---

## ❌ Never Copy Entire Files or Methods

**Never copy entire Chromium files or methods into chromium_src.** Only override the specific part that needs to change, and call the superclass for everything else.

```cpp
// ❌ WRONG - copying entire method (50+ lines) when only 3 lines differ
void SomeClass::LargeMethod() {
  // ... 50 lines copied from Chromium ...
  // Only 3 lines actually changed
}

// ✅ CORRECT - override just the changed part, call super for the rest
void SomeClass::LargeMethod() {
  // Call the original for most of the work
  auto* toast = [builder buildUserNotification];
  // Add only our custom logic
  [toast setCustomField:value];
}
```

---

## ❌ No Multiline Patches - Use Defines

**Never create multiline patches. Use `#define` macros or chromium_src overrides instead.**

---

## ✅ Prefer Subclassing Over Patching

**When possible, subclass Chromium classes using chromium_src overrides instead of patching.** This applies to both C++ and Java.

**C++ example - changing a class via chromium_src:**
```cpp
// ❌ WRONG - patching tab_strip.cc to change behavior
+  BraveNewTabButton* new_tab_button = new BraveNewTabButton(...);

// ✅ CORRECT - chromium_src override that changes the class name
// In chromium_src/chrome/browser/ui/views/tabs/tab_strip.cc
#define NewTabButton BraveNewTabButton
```

**Java example - subclassing instead of patching:**
```java
// ❌ WRONG - patching IncognitoNewTabPageView directly

// ✅ CORRECT - create BraveIncognitoNewTabPageView as subclass
// Patch only changes the superclass reference
```

Subclassing is better for long-term maintenance and makes changes easier to understand. One patch to change a superclass is better than multiple patches to modify individual methods.

---

## ❌ Never Add Comments in Patches

**Never add comments, empty lines, or any non-functional changes in patch files.** Patches should contain only the minimal functional changes needed.

---

## ✅ Use `include` for Extensible Patches

**When a patch adds to a list or block, use an `include` directive to make the patch extensible.** This way additional items can be added in brave-core without modifying the patch.

---

## ✅ Patches Should Use `define` for Extensibility

**Patches should use `#define` macros to be extensible.** This allows adding behavior in brave-core without changing the patch.

```cpp
// ❌ WRONG - patching inline code directly
+  if (permission == AUTOPLAY) return true;

// ✅ CORRECT - define macro that can be changed in brave-core
+#include "brave/chromium_src/path/to/override.h"
+BRAVE_PERMISSION_CONTROLLER_IMPL_METHOD
```

Convention for define names: `BRAVE_ALL_CAPS_ORIGINAL_METHOD_NAME`.

---

## Patch Style Guidelines

- **Keep patches to one line** even if it violates lint character line limits (lint doesn't run on patched files)
- **In XML patches, use HTML comments** (`<!-- -->`) instead of deleting lines to reduce the diff
- **Minimize line modifications** - put additions on separate lines to avoid modifying existing lines
- **Match existing code exactly** when possible so patches auto-resolve during updates

```xml
<!-- ❌ WRONG - deleting XML elements -->
-<LinearLayout ...>
-  ...
-</LinearLayout>

<!-- ✅ CORRECT - commenting out -->
+<!--
 <LinearLayout ...>
   ...
 </LinearLayout>
+-->
```

---

## ✅ Always Use Original Header Paths

**In chromium_src overrides, always `#include` the original header path, not the chromium_src version.**

```cpp
// ❌ WRONG
#include "brave/chromium_src/net/proxy_resolution/proxy_resolution_service.h"

// ✅ CORRECT
#include "net/proxy_resolution/proxy_resolution_service.h"
```

---

## ✅ Use `-=` for List Removal in Patches

**When removing items from GN lists, use `-=` instead of modifying the original line.** This makes the patch an addition rather than a modification.

```gn
# ❌ WRONG - modifying the original deps line
-  public_deps += [ ":chrome_framework_widevine_signature" ]

# ✅ CORRECT - separate removal line (addition-only patch)
+  public_deps -= [ ":chrome_framework_widevine_signature" ]
```

---

## ✅ Replace Entire Classes with Dummy chromium_src Files

**When you need to disable or replace a Chromium class entirely, create a minimal no-op dummy replacement in chromium_src for the `.h` and `.cc` files.** This avoids needing a patch and makes maintenance easier.

```cpp
// ❌ WRONG - two patches to disable a class
patches/components-translate-core-browser-translate_url_fetcher.cc.patch
patches/components-translate-core-browser-translate_url_fetcher.h.patch

// ✅ CORRECT - chromium_src replacement with no-op implementation
// chromium_src/components/translate/core/browser/translate_url_fetcher.h
class TranslateURLFetcher {
 public:
  TranslateURLFetcher() = default;
  bool Request(const GURL& url, Callback callback) { return false; }
};
```

---

## ✅ Use `#define` to Add `virtual` Without Patches

**When a Chromium method needs to be made virtual for override, use a `#define` in a chromium_src override of the header instead of a patch.**

```cpp
// ❌ WRONG - patch to add virtual keyword
-  void StartAutocomplete(...);
+  virtual void StartAutocomplete(...);

// ✅ CORRECT - chromium_src define
#define StartAutocomplete virtual StartAutocomplete
#include "src/components/omnibox/browser/omnibox_controller.h"
#undef StartAutocomplete
```

Note: This technique does not work when the return type is a pointer or reference (e.g., `T* Method()`).

---

## ❌ Never Use `#define final` to Remove the `final` Keyword

**Redefining `final` via `#define` is undefined behavior per the C++ standard and is highly viral.** It can cause build failures in unrelated code that uses `final` in different contexts. Use a patch to remove `final` when subclassing is required, or find alternative approaches.

```cpp
// ❌ WRONG - undefined behavior, viral side effects
#define final
#include "src/chrome/browser/ui/views/side_panel/side_panel_coordinator.h"
#undef final

// ✅ CORRECT - use a minimal patch if no alternative exists
// Or use #define only for specific method names that won't collide
```

---

## ✅ Add Explanation Comments in chromium_src Override Files

**When creating a chromium_src override, include comments explaining why the override is needed.** The override's purpose is not always self-evident from the code alone. Per-function comments explaining each overridden function are sufficient — a global file-level comment is not required if the per-function comments adequately explain the purpose.

```cpp
// chromium_src/chrome/browser/ui/views/tabs/tab_view.cc

// Add Brave-specific tab context menu items. The upstream class doesn't
// support extensibility here, so we replace the menu construction logic.
void TabView::BuildContextMenu() {
  ...
}
```

---

## ✅ Verify chromium_src Header GN Dependencies

**When adding new `#include` directives in chromium_src override files, verify they have required GN dependencies.** The override file is compiled as part of the upstream target, which may not have deps on your Brave headers.

**How to verify:** Temporarily add the same headers to the original upstream file and run `gn check`. If it fails, the upstream target needs the dependency added (typically via a patch or `sources.gni`).

```bash
# Test: add the header to the original file temporarily, then:
gn check out/Default
# If it fails, the dep is missing
```

---

## ❌ chromium_src Must Not Depend on Brave Component Targets

**The chromium_src layer must never have GN dependencies on `//brave/components/` targets.** This prevents patch churn when upstream modularizes targets. Use forward declarations in chromium_src with implementations resolved at link time from other targets via `sources.gni`.

```cpp
// ❌ WRONG - direct include from chromium_src to brave component
// chromium_src/chrome/browser/policy/profile_policy_connector.cc
#include "brave/components/brave_policy/brave_policy_manager.h"

// ✅ CORRECT - forward declare, implement in component, link via sources.gni
// chromium_src/chrome/browser/policy/profile_policy_connector.cc
std::unique_ptr<policy::ConfigurationPolicyProvider>
CreateBraveBrowserPolicyProvider();
// Implementation lives in brave/components/brave_policy/
```

---

## ✅ Add Comments for Non-Obvious nullptr Assignments in chromium_src

**Add comments explaining non-obvious nullptr assignments in chromium_src overrides,** especially for dangling pointer prevention. Since chromium_src code is out of context from the original file, the intent is not always clear.

```cpp
// ❌ WRONG - unclear why setting to nullptr
provider_ = nullptr;

// ✅ CORRECT - explains the intent
// Reset to prevent dangling pointer after BrowserContext shutdown.
provider_ = nullptr;
```

---

## ✅ Use `static_assert` to Protect Against Upstream Enum Changes

**When adding custom values after an upstream enum's last value, add a `static_assert`** to detect if upstream changes their enum count. This prevents value clashes when upstream adds new values.

```cpp
// ✅ CORRECT - protected against upstream changes
constexpr int kBravePolicySource = 10;
static_assert(static_cast<int>(policy::POLICY_SOURCE_COUNT) <= kBravePolicySource,
              "Upstream added new policy sources - update kBravePolicySource");
```

---

## ✅ Use `runtime_enabled_features.override.json5` for Blink Features

**When adding Brave-specific Blink runtime-enabled features, add them to `runtime_enabled_features.override.json5` instead of patching `runtime_enabled_features.json5`.** The override file is designed for downstream additions and never changes upstream, preventing patch conflicts.

```json5
// ❌ WRONG - patching runtime_enabled_features.json5 (causes conflicts)

// ✅ CORRECT - add to override file
// third_party/blink/renderer/platform/runtime_enabled_features.override.json5
{
  name: "BraveGlobalPrivacyControl",
  public: true,
  base_feature: "none",
},
```
