# Build System

## ✅ DEPS File - Use Commit Hashes

**In DEPS files, always use commit hashes rather than branch names or tags.** Commit hashes are immutable and ensure reproducible builds.

---

## ❌ Minimize Whitespace Changes in Patches

**Leave whitespace intact in patch files to minimize diff size.** Only change what's functionally necessary. Unnecessary whitespace changes make patches harder to review and more likely to conflict.

---

## ✅ Reuse Existing GN Config Args

**Check for existing GN args before creating new ones.** Duplicating config arguments (e.g., creating `brave_android_keystore_path` when `android_keystore_path` already exists) adds confusion and maintenance burden.

---

## ✅ Python Build Scripts

Python scripts used in the build system should follow these conventions:

- **Use `argparse`** for command-line arguments, not `sys.argv` directly
- **Use standard `Main()` pattern** to ensure proper error propagation to GN:
  ```python
  def Main():
      ...
      return 0

  if __name__ == '__main__':
      sys.exit(Main())
  ```

---

## ✅ Group Sources and Deps Together in BUILD.gn

**Always group `sources` and `deps` in the same block.** Don't dump everything in one place - move files to separate BUILD.gn files when needed so it's clear which deps belong to which sources.

```gn
# ❌ WRONG - all deps in root BUILD.gn, hard to track
source_set("browser") {
  sources = [ ... 200 files ... ]
  deps = [ ... 100 deps ... ]
}

# ✅ CORRECT - grouped by feature
source_set("branded_wallpaper") {
  sources = [ "branded_wallpaper.cc" ]
  deps = [ "//brave/components/ntp_background_images" ]
}
```

---

## ❌ Never More Than One Guard Per Target

**There should almost never be more than one of the same guard in any given BUILD.gn target.** If you find yourself repeating the same `if (enable_brave_foo)` block multiple times, consolidate.

---

## ✅ Use Buildflags Instead of OS Guards for Features

**Use buildflags (`BUILDFLAG(ENABLE_FOO)`) instead of OS platform guards (`is_linux`, `is_win`) for feature-specific code.** Platform guards without buildflags are deprecated.

```gn
# ❌ WRONG - deprecated OS guard
if (is_linux) {
  sources += [ "tor_launcher_linux.cc" ]
}

# ✅ CORRECT - use buildflag
if (enable_tor) {
  sources += [ "tor_launcher.cc" ]
}
```

Also: only feature-specific header files should go inside feature guards. Don't put unrelated headers inside a feature guard block even if they're only currently used by that feature.

---

## ✅ Buildflag Naming Convention

**Use `enable_brave_<feature>` as the naming convention for buildflags.**

```gn
# ❌ WRONG
brave_perf_predictor_enabled = true

# ✅ CORRECT
enable_brave_perf_predictor = true
```

---

## ❌ Never Add Empty Lines in Patches

**Never add empty lines in patch files.** Keep patches minimal - only change what's functionally necessary.

---

## ❌ Don't Duplicate License Files

**Never duplicate Chromium or other project license files.** Use special cases or references instead.

---

## ✅ JSON Resources Should Go in GRD Files

**JSON data files should be packaged as resources in `.grd` files, not loaded from disk.** This allows the same data to be used from both C++ and JS.

See `bat_ads_resources.grd` for an example.

---

## ✅ Always Double-Check Dependencies

**Always verify you have deps for all includes and used symbols.** Missing deps can work by accident through transitive dependencies but will break when those transitive deps change.

```gn
# Check for deps matching your includes:
# #include "url/gurl.h" -> needs dep "//url"
# #include "extensions/browser/..." -> needs dep "//extensions/browser/..."
```

---

## ✅ Use `//brave/` Deps Instead of Modifying Visibility Lists

**When adding deps from Chromium targets to Brave code, use high-level `//brave/` targets (e.g., `//brave/utility`) instead of modifying Chromium visibility lists.** Visibility lists exist to prevent exactly this kind of cross-boundary dependency.

```gn
# ❌ WRONG - modifying Chromium visibility list
visibility += [ "//brave/components/brave_rewards/browser" ]

# ✅ CORRECT - use a brave target that already has visibility
deps += [ "//brave/utility" ]
```

---

## ✅ Add `#endif` Comments for Clarity

**Add `#endif` comments to clarify what each `#endif` is closing.** See the "Refined Rule: `#endif` Comments Based on Block Length" section below for specific guidance on when to include vs omit these comments.

```cpp
#if BUILDFLAG(ENABLE_SPELLCHECK)
#include "components/spellcheck/common/spellcheck_features.h"
#endif  // BUILDFLAG(ENABLE_SPELLCHECK)
```

---

## ✅ Scripts Go in brave/scripts

**Build and utility scripts should go in `brave/scripts/`, not in `build/` or other Chromium directories.**

---

## ❌ Avoid Separate Repositories

**Avoid creating separate repositories for Brave features.** Separate repos are harder to manage, code review, and maintain. Prefer keeping code within brave-core.

---

## ✅ Add New URLs to the Network Audit Whitelist

**When adding any new network endpoint URL, it must be added to the network audit whitelist** at `lib/whitelistedUrlPrefixes.js` in brave-browser. Without this, the network audit check will fail.

---

## ✅ Keep Lists Sorted Alphabetically

**When adding items to lists (includes, deps, sources, histograms, features), maintain alphabetical ordering.** Sorted lists reduce merge conflicts and make items easier to find.

```gn
# ❌ WRONG - unsorted
deps = [
  "//brave/components/brave_shields",
  "//brave/components/brave_ads",
  "//brave/components/brave_wallet",
]

# ✅ CORRECT - alphabetically sorted
deps = [
  "//brave/components/brave_ads",
  "//brave/components/brave_shields",
  "//brave/components/brave_wallet",
]
```

---

## ❌ Don't Use OS Guards as Proxy for Feature Guards

**Use the correct feature guard (`brave_wallet_enabled`, `enable_extensions`) instead of approximating with OS guards (`!is_android && !is_ios`).** OS guards can get out of sync with the actual feature flag logic.

```gn
# ❌ WRONG - OS guard as proxy for feature
if (!is_android && !is_ios) {
  sources += [ "brave_wallet_utils.cc" ]
}

# ✅ CORRECT - actual feature guard
if (brave_wallet_enabled) {
  sources += [ "brave_wallet_utils.cc" ]
}
```

---

## ❌ Don't Have Both `BUILD.gn` and `sources.gni` in the Same Directory

**A directory should contain either a `BUILD.gn` file (preferred) or a `sources.gni` file, but not both.** Having both creates confusion about which is authoritative and makes dependency tracking harder.

---

## ✅ Create Test Targets in Component BUILD.gn

**Unit test files should have a test target in the component's `BUILD.gn`, not be individually listed in the top-level `test/BUILD.gn`.** The top-level test target should depend on the component's test target.

```gn
# ❌ WRONG - individual test files in top-level test/BUILD.gn
sources += [ "//brave/components/ai_chat/core/credential_manager_unittest.cc" ]

# ✅ CORRECT - test target in component BUILD.gn
# components/ai_chat/core/BUILD.gn
source_set("unit_tests") {
  sources = [ "credential_manager_unittest.cc" ]
  deps = [ ... ]
}
# test/BUILD.gn
deps += [ "//brave/components/ai_chat/core:unit_tests" ]
```

---

## ✅ Use `PlatformBrowserTest` for Cross-Platform Browser Tests

**Browser tests that should run on both desktop and Android should use `PlatformBrowserTest` as the base class instead of `InProcessBrowserTest`.**

```cpp
#if BUILDFLAG(IS_ANDROID)
#include "chrome/test/base/android/android_browser_test.h"
#else
#include "chrome/test/base/in_process_browser_test.h"
#endif

// ❌ WRONG
class MyBrowserTest : public InProcessBrowserTest {};

// ✅ CORRECT
class MyBrowserTest : public PlatformBrowserTest {};
```

---

## ✅ Use `public_deps` for Header-File Includes in BUILD.gn

**When a dependency's headers are included in your target's header files (not just .cc files), that dependency must be listed in `public_deps`, not `deps`.** This ensures consumers of your target also get the transitive include paths they need.

```gn
# ❌ WRONG - header-visible dependency in regular deps
source_set("my_service") {
  sources = [ "my_service.h", "my_service.cc" ]
  deps = [ "//components/prefs" ]  # prefs is used in my_service.h!
}

# ✅ CORRECT - header dependency in public_deps
source_set("my_service") {
  sources = [ "my_service.h", "my_service.cc" ]
  public_deps = [ "//components/prefs" ]  # used in header
  deps = [ "//base" ]  # only used in .cc
}
```

---

## ✅ Use `deps +=` with a Variable for Extensible GN Patches

**When a patch adds dependencies to a Chromium BUILD.gn target, define a variable in Brave code and patch only the variable reference.** This allows adding/removing deps without modifying the patch.

```gn
# ❌ WRONG - patching inline deps
+  deps += [ "//brave/browser/ui/views/location_bar" ]

# ✅ CORRECT - patch references a variable
+  deps += brave_browser_window_deps
# In brave code:
brave_browser_window_deps = [
  "//brave/browser/ui/views/location_bar",
]
```

---

## ✅ Utility Scripts Should Be Python, Not Node.js or Shell

**Build and utility scripts in brave-core should be written in Python (using `vpython` from depot tools), not Node.js or shell scripts.** This follows Chromium conventions, avoids additional runtime dependencies, and works on all platforms including Windows.

---

## ✅ Unconditional Buildflags Deps with Conditional `deps +=`

**When adding `deps +=` inside an `if(enable_feature)` block in GN, always add an unconditional `buildflags` dependency outside the conditional.** The buildflags header is needed even when the feature is disabled (for the `#if BUILDFLAG(...)` check itself). Run `gn check` with the buildflag disabled to verify.

```gn
# ❌ WRONG - buildflags dep only inside conditional
if (enable_brave_rewards) {
  deps += [
    "//brave/components/brave_rewards/common/buildflags",
    "//brave/components/brave_rewards/browser",
  ]
}

# ✅ CORRECT - buildflags dep unconditional
deps += [
  "//brave/components/brave_rewards/common/buildflags",
]
if (enable_brave_rewards) {
  deps += [ "//brave/components/brave_rewards/browser" ]
}
```

---

## ✅ Restrict `source_set` Visibility for Internal Targets

**When using `source_set` for internal component targets, restrict target visibility** to prevent external use. If the target needs to be used externally, use `component` or `static_library` instead.

```gn
# ❌ WRONG - internal source_set with default (public) visibility
source_set("internal_network") {
  sources = [ ... ]
}

# ✅ CORRECT - restricted visibility
source_set("internal_network") {
  visibility = [ ":*" ]  # Only usable within this BUILD.gn
  sources = [ ... ]
}
```

---

## ✅ Python File Writes: Use `newline='\n'`

**When writing files from Python scripts, always specify `newline='\n'`** in `open()` to ensure consistent LF line endings across platforms (especially Windows).

```python
# ❌ WRONG - platform-dependent line endings
with open(output_path, 'w') as f:
    f.write(content)

# ✅ CORRECT - consistent LF endings
with open(output_path, 'w', newline='\n') as f:
    f.write(content)
```

---

## ✅ Use `include_rules` for Common Includes, `specific_include_rules` for Edge Cases

**In DEPS files, use `include_rules` for generally allowed includes across all files in a directory.** Reserve `specific_include_rules` for edge cases where an include should only be allowed in specific files.

```python
# ❌ WRONG - using specific_include_rules for commonly needed includes
specific_include_rules = {
  ".*\.cc": [
    "+brave/components/content_settings/core/common",
    "+brave/components/content_settings/core/browser",
  ],
}

# ✅ CORRECT - include_rules for generally allowed includes
include_rules = [
  "+brave/components/content_settings/core/common",
  "+brave/components/content_settings/core/browser",
]
```

---

## ✅ Bump `resource_ids.spec` by 5

**When adding new resource IDs in `resource_ids.spec`, bump the next ID by 5 (not 1)** to leave room for additions without conflicting with adjacent entries.

---

## ✅ Use `component()` Not `static_library()` for Service GN Targets

**Mojo service targets should use `component()` instead of `static_library()` in BUILD.gn.** Components support dynamic linking and are the correct target type for service implementations.

---

## ❌ Unit Tests for Components Must NOT Live in Browser

**Unit tests for code in `//brave/components` must not be placed in `//brave/browser`.** Tests should live alongside the code they test. Use `content::RenderViewHostTestHarness` for component-level tests that need content layer support.

```gn
# ❌ WRONG - component test in browser directory
# browser/ai_chat/associated_link_content_unittest.cc
# testing code from components/ai_chat/content/browser/

# ✅ CORRECT - test alongside the code
# components/ai_chat/content/browser/associated_link_content_unittest.cc
source_set("unit_tests") {
  sources = [ "associated_link_content_unittest.cc" ]
}
```

---

## ✅ Place Includes Inside BUILDFLAG Guards When Only Used There

**When an `#include` is only used inside a `#if BUILDFLAG(...)` block, the include must also be inside that guard.** An unconditional include for a conditionally-used header breaks builds when the feature is disabled.

```cpp
// ❌ WRONG - unconditional include for conditionally-used header
#include "chrome/browser/extensions/extension_web_ui.h"
// ...
#if BUILDFLAG(ENABLE_EXTENSIONS)
  IsChromeURLOverridden(...);  // uses extension_web_ui.h
#endif

// ✅ CORRECT - include inside the same guard
#if BUILDFLAG(ENABLE_EXTENSIONS)
#include "chrome/browser/extensions/extension_web_ui.h"
  IsChromeURLOverridden(...);
#endif
```

---

## ✅ Merge Consecutive Identical BUILDFLAG Blocks

**When multiple consecutive code regions use the same `#if BUILDFLAG(...)` condition, merge them into a single guard block.**

```cpp
// ❌ WRONG - redundant guards
#if BUILDFLAG(ENABLE_BRAVE_REWARDS)
#include "brave/components/brave_rewards/core/buildflags.h"
#endif

#if BUILDFLAG(ENABLE_BRAVE_REWARDS)
namespace rewards { ... }
#endif

// ✅ CORRECT - single merged block
#if BUILDFLAG(ENABLE_BRAVE_REWARDS)
#include "brave/components/brave_rewards/core/buildflags.h"
namespace rewards { ... }
#endif
```

---

## ✅ DEPS Allowlist Paths Must Exactly Match Include Paths

**DEPS file allowlist paths must exactly match the `#include` paths used in source files.** A mismatch (e.g., `common/` vs `core/`) means the DEPS check doesn't validate the right file.

---

## ✅ Use `assert()` at Top of Entire-Feature BUILD.gn Files

**If an entire BUILD.gn file belongs to a feature, use `assert(enable_feature)` at the top** rather than wrapping individual blocks in `if (enable_feature)`.

```gn
# ❌ WRONG - wrapping everything inside a conditional
if (enable_brave_wallet) {
  source_set("wallet_tests") {
    sources = [ ... ]
  }
}

# ✅ CORRECT - assert at top
assert(enable_brave_wallet)
source_set("wallet_tests") {
  sources = [ ... ]
}
```

---

## ✅ Add `static_assert` in Public Headers for Build Flag Guards

**When introducing a build flag for a component, add `static_assert` in public-facing headers** to catch accidental inclusion when the feature is disabled.

```cpp
// In brave/components/brave_wallet/browser/wallet_service.h
#include "brave/components/brave_wallet/common/buildflags/buildflags.h"
static_assert(BUILDFLAG(ENABLE_BRAVE_WALLET));
```

---

## ❌ Don't Use `nogncheck` - Fix the Underlying Dep Guard

**Do not use `nogncheck` to suppress gn check failures.** Instead fix the underlying GN dependency to be correctly conditional. `nogncheck` is a code smell that masks real build dependency issues.

```cpp
// ❌ WRONG - suppressing the real problem
#include "brave/components/foo/bar.h"  // nogncheck

// ✅ CORRECT - fix the GN dep to be properly guarded
// Ensure the dep is conditionally added in BUILD.gn
```

---

## ✅ GN Deps Guarded by Feature Flags Only, Not Platform Guards

**Within a single GN target, deps should be added behind the relevant buildflags only, not nested inside platform guards.** GN and C++ guards should always match.

```gn
# ❌ WRONG - nested inside platform guard
if (is_mac) {
  if (enable_tor) {
    deps += [ "//brave/components/tor" ]
  }
}

# ✅ CORRECT - feature flag only
if (enable_tor) {
  deps += [ "//brave/components/tor" ]
}
```

---

## ✅ When Disabling a Feature, Compile Out Its Tests

**When a build flag disables a feature, exclude the feature-specific test files from the build** using conditionals rather than trying to fix compilation errors by adjusting test dependencies.

```gn
# ❌ WRONG - fixing deps to make disabled feature tests compile
deps += [ "//brave/components/brave_rewards" ]  # just for tests

# ✅ CORRECT - compile out disabled feature tests
if (enable_brave_rewards) {
  sources += [ "rewards_service_unittest.cc" ]
}
```

---

## ✅ Build Flag Validation Requires Both States

**When adding a build flag, run `gn_check`, unit tests, component tests, browser tests, and presubmit with the flag both enabled AND disabled.** Issues frequently only appear in the disabled state.

---

## ✅ Use Chromium UI Preprocessor for Conditional WebUI Code

**Use `// <if expr="enable_feature">` in JS and `<if expr="enable_feature">` in HTML to conditionally compile feature-specific WebUI code.** This completely removes the code from the build when the feature is disabled, rather than relying solely on runtime `loadTimeData` checks.

```js
// ✅ CORRECT - code removed at build time when feature disabled
// <if expr="enable_speedreader">
import { SpeedreaderPage } from './speedreader_page.js';
// </if>
```

---

## ✅ Refined Rule: `#endif` Comments Based on Block Length

**Clarification of the `#endif` comment rule:**
- **Always add** for blocks > 3 lines
- **Always add** when inside nested `#if` blocks
- **Always add** when surrounding code already uses them (consistency)
- **Can omit** for short (1-2 line), unambiguous blocks

---

## ✅ Assert Build Flag Dependencies Between Features

**When Feature A depends on Feature B, assert Feature B's build flag is true when Feature A is enabled** rather than making Feature A work without Feature B for unsupported configurations.

```gn
# In brave/components/brave_rewards/BUILD.gn
assert(enable_brave_wallet,
       "Rewards requires Wallet (enable_brave_wallet=true)")
```

---

## ✅ Share Constants via Common Headers

**Shared constants (like limits, URLs, keys) should be defined in a common header** to avoid duplicate definitions across implementation, test, and other files.

```cpp
// ❌ WRONG - same constant in 3 files
// model_service.cc
constexpr char kOllamaEndpoint[] = "http://localhost:11434";
// model_service_unittest.cc
constexpr char kOllamaEndpoint[] = "http://localhost:11434";
// ollama_model_fetcher.cc
constexpr char kOllamaEndpoint[] = "http://localhost:11434";

// ✅ CORRECT - shared header
// common/constants.h
inline constexpr char kOllamaEndpoint[] = "http://localhost:11434";
```
